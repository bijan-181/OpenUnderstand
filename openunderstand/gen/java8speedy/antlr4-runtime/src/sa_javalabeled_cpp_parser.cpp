/*
 * This file was auto-generated by speedy-antlr-tool v1.1.0
 *  https://github.com/amykyta3/speedy-antlr-tool
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstring>

#include "antlr4-runtime.h"
#include "JavaLexer.h"
#include "JavaLabeledParser.h"
#include "speedy_antlr.h"

#include "sa_javalabeled_translator.h"

/*
 * Python function prototype:
 *  do_parse(
 *      parser_cls:antlr4.Parser,
 *      stream:antlr4.InputStream,
 *      entry_rule_name:str,
 *      sa_err_listener:SA_ErrorListener
 *  )
 */
PyObject* do_parse(PyObject *self, PyObject *args) {
    PyObject *strdata = NULL;
    PyObject *result = NULL;
    PyObject *token_module = NULL;

    try {
        // Get args
        PyObject *parser_cls = NULL;
        PyObject *stream = NULL;
        const char *entry_rule_name = NULL;
        PyObject *sa_err_listener = NULL;
        if(!PyArg_ParseTuple(args,
            "OOsO:do_parse",
            &parser_cls, &stream, &entry_rule_name, &sa_err_listener
        )) {
            return NULL;
        }

        // Extract input stream's string
        const char *cstrdata;
        Py_ssize_t bufsize;
        strdata = PyObject_GetAttrString(stream, "strdata");
        if(!strdata) throw speedy_antlr::PythonException();
        cstrdata = PyUnicode_AsUTF8AndSize(strdata, &bufsize);
        if(!cstrdata) throw speedy_antlr::PythonException();

        // Create an antlr InputStream object
        antlr4::ANTLRInputStream cpp_stream(cstrdata, bufsize);

        // in case error listener is overridden
        token_module = PyImport_ImportModule("antlr4.Token");
        if(!token_module) throw speedy_antlr::PythonException();
        speedy_antlr::Translator translator(parser_cls, stream);
        speedy_antlr::ErrorTranslatorListener err_listener(&translator, sa_err_listener);

        // Lex
        JavaLexer lexer(&cpp_stream);
        if(sa_err_listener != Py_None){
            lexer.removeErrorListeners();
            lexer.addErrorListener(&err_listener);
        }
        antlr4::CommonTokenStream token_stream(&lexer);
        token_stream.fill();

        // Parse
        JavaLabeledParser parser(&token_stream);
        if(sa_err_listener != Py_None){
            parser.removeErrorListeners();
            parser.addErrorListener(&err_listener);
        }
        antlr4::tree::ParseTree *parse_tree;
        if(!strcmp(entry_rule_name, "compilationUnit")){
            parse_tree = parser.compilationUnit();

        } else if(!strcmp(entry_rule_name, "packageDeclaration")){
            parse_tree = parser.packageDeclaration();

        } else if(!strcmp(entry_rule_name, "importDeclaration")){
            parse_tree = parser.importDeclaration();

        } else if(!strcmp(entry_rule_name, "typeDeclaration")){
            parse_tree = parser.typeDeclaration();

        } else if(!strcmp(entry_rule_name, "modifier")){
            parse_tree = parser.modifier();

        } else if(!strcmp(entry_rule_name, "classOrInterfaceModifier")){
            parse_tree = parser.classOrInterfaceModifier();

        } else if(!strcmp(entry_rule_name, "variableModifier")){
            parse_tree = parser.variableModifier();

        } else if(!strcmp(entry_rule_name, "classDeclaration")){
            parse_tree = parser.classDeclaration();

        } else if(!strcmp(entry_rule_name, "typeParameters")){
            parse_tree = parser.typeParameters();

        } else if(!strcmp(entry_rule_name, "typeParameter")){
            parse_tree = parser.typeParameter();

        } else if(!strcmp(entry_rule_name, "typeBound")){
            parse_tree = parser.typeBound();

        } else if(!strcmp(entry_rule_name, "enumDeclaration")){
            parse_tree = parser.enumDeclaration();

        } else if(!strcmp(entry_rule_name, "enumConstants")){
            parse_tree = parser.enumConstants();

        } else if(!strcmp(entry_rule_name, "enumConstant")){
            parse_tree = parser.enumConstant();

        } else if(!strcmp(entry_rule_name, "enumBodyDeclarations")){
            parse_tree = parser.enumBodyDeclarations();

        } else if(!strcmp(entry_rule_name, "interfaceDeclaration")){
            parse_tree = parser.interfaceDeclaration();

        } else if(!strcmp(entry_rule_name, "classBody")){
            parse_tree = parser.classBody();

        } else if(!strcmp(entry_rule_name, "interfaceBody")){
            parse_tree = parser.interfaceBody();

        } else if(!strcmp(entry_rule_name, "classBodyDeclaration")){
            parse_tree = parser.classBodyDeclaration();

        } else if(!strcmp(entry_rule_name, "memberDeclaration")){
            parse_tree = parser.memberDeclaration();

        } else if(!strcmp(entry_rule_name, "methodDeclaration")){
            parse_tree = parser.methodDeclaration();

        } else if(!strcmp(entry_rule_name, "methodBody")){
            parse_tree = parser.methodBody();

        } else if(!strcmp(entry_rule_name, "typeTypeOrVoid")){
            parse_tree = parser.typeTypeOrVoid();

        } else if(!strcmp(entry_rule_name, "genericMethodDeclaration")){
            parse_tree = parser.genericMethodDeclaration();

        } else if(!strcmp(entry_rule_name, "genericConstructorDeclaration")){
            parse_tree = parser.genericConstructorDeclaration();

        } else if(!strcmp(entry_rule_name, "constructorDeclaration")){
            parse_tree = parser.constructorDeclaration();

        } else if(!strcmp(entry_rule_name, "fieldDeclaration")){
            parse_tree = parser.fieldDeclaration();

        } else if(!strcmp(entry_rule_name, "interfaceBodyDeclaration")){
            parse_tree = parser.interfaceBodyDeclaration();

        } else if(!strcmp(entry_rule_name, "interfaceMemberDeclaration")){
            parse_tree = parser.interfaceMemberDeclaration();

        } else if(!strcmp(entry_rule_name, "constDeclaration")){
            parse_tree = parser.constDeclaration();

        } else if(!strcmp(entry_rule_name, "constantDeclarator")){
            parse_tree = parser.constantDeclarator();

        } else if(!strcmp(entry_rule_name, "interfaceMethodDeclaration")){
            parse_tree = parser.interfaceMethodDeclaration();

        } else if(!strcmp(entry_rule_name, "interfaceMethodModifier")){
            parse_tree = parser.interfaceMethodModifier();

        } else if(!strcmp(entry_rule_name, "genericInterfaceMethodDeclaration")){
            parse_tree = parser.genericInterfaceMethodDeclaration();

        } else if(!strcmp(entry_rule_name, "variableDeclarators")){
            parse_tree = parser.variableDeclarators();

        } else if(!strcmp(entry_rule_name, "variableDeclarator")){
            parse_tree = parser.variableDeclarator();

        } else if(!strcmp(entry_rule_name, "variableDeclaratorId")){
            parse_tree = parser.variableDeclaratorId();

        } else if(!strcmp(entry_rule_name, "variableInitializer")){
            parse_tree = parser.variableInitializer();

        } else if(!strcmp(entry_rule_name, "arrayInitializer")){
            parse_tree = parser.arrayInitializer();

        } else if(!strcmp(entry_rule_name, "classOrInterfaceType")){
            parse_tree = parser.classOrInterfaceType();

        } else if(!strcmp(entry_rule_name, "typeArgument")){
            parse_tree = parser.typeArgument();

        } else if(!strcmp(entry_rule_name, "qualifiedNameList")){
            parse_tree = parser.qualifiedNameList();

        } else if(!strcmp(entry_rule_name, "formalParameters")){
            parse_tree = parser.formalParameters();

        } else if(!strcmp(entry_rule_name, "formalParameterList")){
            parse_tree = parser.formalParameterList();

        } else if(!strcmp(entry_rule_name, "formalParameter")){
            parse_tree = parser.formalParameter();

        } else if(!strcmp(entry_rule_name, "lastFormalParameter")){
            parse_tree = parser.lastFormalParameter();

        } else if(!strcmp(entry_rule_name, "qualifiedName")){
            parse_tree = parser.qualifiedName();

        } else if(!strcmp(entry_rule_name, "literal")){
            parse_tree = parser.literal();

        } else if(!strcmp(entry_rule_name, "integerLiteral")){
            parse_tree = parser.integerLiteral();

        } else if(!strcmp(entry_rule_name, "floatLiteral")){
            parse_tree = parser.floatLiteral();

        } else if(!strcmp(entry_rule_name, "altAnnotationQualifiedName")){
            parse_tree = parser.altAnnotationQualifiedName();

        } else if(!strcmp(entry_rule_name, "annotation")){
            parse_tree = parser.annotation();

        } else if(!strcmp(entry_rule_name, "elementValuePairs")){
            parse_tree = parser.elementValuePairs();

        } else if(!strcmp(entry_rule_name, "elementValuePair")){
            parse_tree = parser.elementValuePair();

        } else if(!strcmp(entry_rule_name, "elementValue")){
            parse_tree = parser.elementValue();

        } else if(!strcmp(entry_rule_name, "elementValueArrayInitializer")){
            parse_tree = parser.elementValueArrayInitializer();

        } else if(!strcmp(entry_rule_name, "annotationTypeDeclaration")){
            parse_tree = parser.annotationTypeDeclaration();

        } else if(!strcmp(entry_rule_name, "annotationTypeBody")){
            parse_tree = parser.annotationTypeBody();

        } else if(!strcmp(entry_rule_name, "annotationTypeElementDeclaration")){
            parse_tree = parser.annotationTypeElementDeclaration();

        } else if(!strcmp(entry_rule_name, "annotationTypeElementRest")){
            parse_tree = parser.annotationTypeElementRest();

        } else if(!strcmp(entry_rule_name, "annotationMethodOrConstantRest")){
            parse_tree = parser.annotationMethodOrConstantRest();

        } else if(!strcmp(entry_rule_name, "annotationMethodRest")){
            parse_tree = parser.annotationMethodRest();

        } else if(!strcmp(entry_rule_name, "annotationConstantRest")){
            parse_tree = parser.annotationConstantRest();

        } else if(!strcmp(entry_rule_name, "defaultValue")){
            parse_tree = parser.defaultValue();

        } else if(!strcmp(entry_rule_name, "block")){
            parse_tree = parser.block();

        } else if(!strcmp(entry_rule_name, "blockStatement")){
            parse_tree = parser.blockStatement();

        } else if(!strcmp(entry_rule_name, "localVariableDeclaration")){
            parse_tree = parser.localVariableDeclaration();

        } else if(!strcmp(entry_rule_name, "localTypeDeclaration")){
            parse_tree = parser.localTypeDeclaration();

        } else if(!strcmp(entry_rule_name, "statement")){
            parse_tree = parser.statement();

        } else if(!strcmp(entry_rule_name, "catchClause")){
            parse_tree = parser.catchClause();

        } else if(!strcmp(entry_rule_name, "catchType")){
            parse_tree = parser.catchType();

        } else if(!strcmp(entry_rule_name, "finallyBlock")){
            parse_tree = parser.finallyBlock();

        } else if(!strcmp(entry_rule_name, "resourceSpecification")){
            parse_tree = parser.resourceSpecification();

        } else if(!strcmp(entry_rule_name, "resources")){
            parse_tree = parser.resources();

        } else if(!strcmp(entry_rule_name, "resource")){
            parse_tree = parser.resource();

        } else if(!strcmp(entry_rule_name, "switchBlockStatementGroup")){
            parse_tree = parser.switchBlockStatementGroup();

        } else if(!strcmp(entry_rule_name, "switchLabel")){
            parse_tree = parser.switchLabel();

        } else if(!strcmp(entry_rule_name, "forControl")){
            parse_tree = parser.forControl();

        } else if(!strcmp(entry_rule_name, "forInit")){
            parse_tree = parser.forInit();

        } else if(!strcmp(entry_rule_name, "enhancedForControl")){
            parse_tree = parser.enhancedForControl();

        } else if(!strcmp(entry_rule_name, "parExpression")){
            parse_tree = parser.parExpression();

        } else if(!strcmp(entry_rule_name, "expressionList")){
            parse_tree = parser.expressionList();

        } else if(!strcmp(entry_rule_name, "methodCall")){
            parse_tree = parser.methodCall();

        } else if(!strcmp(entry_rule_name, "expression")){
            parse_tree = parser.expression();

        } else if(!strcmp(entry_rule_name, "lambdaExpression")){
            parse_tree = parser.lambdaExpression();

        } else if(!strcmp(entry_rule_name, "lambdaParameters")){
            parse_tree = parser.lambdaParameters();

        } else if(!strcmp(entry_rule_name, "lambdaBody")){
            parse_tree = parser.lambdaBody();

        } else if(!strcmp(entry_rule_name, "primary")){
            parse_tree = parser.primary();

        } else if(!strcmp(entry_rule_name, "classType")){
            parse_tree = parser.classType();

        } else if(!strcmp(entry_rule_name, "creator")){
            parse_tree = parser.creator();

        } else if(!strcmp(entry_rule_name, "createdName")){
            parse_tree = parser.createdName();

        } else if(!strcmp(entry_rule_name, "innerCreator")){
            parse_tree = parser.innerCreator();

        } else if(!strcmp(entry_rule_name, "arrayCreatorRest")){
            parse_tree = parser.arrayCreatorRest();

        } else if(!strcmp(entry_rule_name, "classCreatorRest")){
            parse_tree = parser.classCreatorRest();

        } else if(!strcmp(entry_rule_name, "explicitGenericInvocation")){
            parse_tree = parser.explicitGenericInvocation();

        } else if(!strcmp(entry_rule_name, "typeArgumentsOrDiamond")){
            parse_tree = parser.typeArgumentsOrDiamond();

        } else if(!strcmp(entry_rule_name, "nonWildcardTypeArgumentsOrDiamond")){
            parse_tree = parser.nonWildcardTypeArgumentsOrDiamond();

        } else if(!strcmp(entry_rule_name, "nonWildcardTypeArguments")){
            parse_tree = parser.nonWildcardTypeArguments();

        } else if(!strcmp(entry_rule_name, "typeList")){
            parse_tree = parser.typeList();

        } else if(!strcmp(entry_rule_name, "typeType")){
            parse_tree = parser.typeType();

        } else if(!strcmp(entry_rule_name, "primitiveType")){
            parse_tree = parser.primitiveType();

        } else if(!strcmp(entry_rule_name, "typeArguments")){
            parse_tree = parser.typeArguments();

        } else if(!strcmp(entry_rule_name, "superSuffix")){
            parse_tree = parser.superSuffix();

        } else if(!strcmp(entry_rule_name, "explicitGenericInvocationSuffix")){
            parse_tree = parser.explicitGenericInvocationSuffix();

        } else if(!strcmp(entry_rule_name, "arguments")){
            parse_tree = parser.arguments();

        } else {
            PyErr_SetString(PyExc_ValueError, "Invalid entry_rule_name");
            throw speedy_antlr::PythonException();
        }

        // Translate Parse tree to Python
        SA_JavaLabeledTranslator visitor(&translator);
        result = visitor.visit(parse_tree);

        // Clean up data
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);

        return result;

    } catch(speedy_antlr::PythonException &e) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // Python exception already has error indicator set
        return NULL;
    } catch(...) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // An internal C++ exception was thrown.
        // Set error indicator to a generic runtime error
        PyErr_SetString(PyExc_RuntimeError, "Internal error");
        return NULL;
    }
}


extern "C" {

    static PyObject* c_do_parse(PyObject *self, PyObject *args) {
        return do_parse(self, args);
    }

    static PyMethodDef methods[] = {
        {
            "do_parse",  c_do_parse, METH_VARARGS,
            "Run parser"
        },
        {NULL, NULL, 0, NULL} /* Sentinel */
    };

    static struct PyModuleDef module = {
        PyModuleDef_HEAD_INIT,
        "sa_javalabeled_cpp_parser",   /* name of module */
        NULL, /* module documentation, may be NULL */
        -1,       /* size of per-interpreter state of the module,
                    or -1 if the module keeps state in global variables. */
        methods
    };
}


PyMODINIT_FUNC
PyInit_sa_javalabeled_cpp_parser(void) {
    PyObject *m = PyModule_Create(&module);
    return m;
}
